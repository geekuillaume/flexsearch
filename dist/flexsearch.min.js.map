{"version":3,"file":"flexsearch.min.js","sources":["../src/common.js","../src/lang.js","../src/lang/latin/default.js","../src/async.js","../src/intersect.js","../src/cache.js","../src/index.js","../src/document.js","../src/lib.js"],"sourcesContent":["export function parse_option(value, default_value){\n  return typeof value !== 'undefined' ? value : default_value;\n}\n\n/**\n * @param {!number} count\n * @returns {Array<Object>}\n */\n\nexport function create_object_array(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = create_object();\n  }\n\n  return array;\n}\n\nexport function create_arrays(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = [];\n  }\n\n  return array;\n}\n\n/**\n * @param {!Object} obj\n * @returns {Array<string>}\n */\n\nexport function get_keys(obj){\n  return Object.keys(obj);\n}\n\nexport function create_object(){\n  return Object.create(null);\n}\n\nexport function concat(arrays){\n  return [].concat.apply([], arrays);\n}\n\nexport function sort_by_length_down(a, b){\n  return b.length - a.length;\n}\n\nexport function is_array(val){\n  return val.constructor === Array;\n}\n\nexport function is_string(val){\n  return typeof val === 'string';\n}\n\nexport function is_object(val){\n  return typeof val === 'object';\n}\n\nexport function is_function(val){\n  return typeof val === 'function';\n}\n","import { create_object, get_keys } from './common.js';\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n * @this IndexInterface\n */\n\nexport function pipeline(str, normalize, split, _collapse){\n  if(str){\n    if(normalize){\n      str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n    }\n\n    if(this.matcher){\n      str = replace(str, this.matcher);\n    }\n\n    if(this.stemmer && (str.length > 1)){\n      str = replace(str, this.stemmer);\n    }\n\n    if(_collapse && (str.length > 1)){\n      str = collapse(str);\n    }\n\n    if(split || (split === '')){\n      const words = str.split(/** @type {string|RegExp} */ (split));\n\n      return this.filter ? filter(words, this.filter) : words;\n    }\n  }\n\n  return str;\n}\n\nexport const regex_whitespace = /[\\p{Z}\\p{S}\\p{P}\\p{C}]+/u;\nconst regex_normalize = /[\\u0300-\\u036f]/g;\n\nexport function normalize(str){\n  if(str.normalize){\n    str = str.normalize('NFD').replace(regex_normalize, '');\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n */\n\n// FlexSearch.prototype.pipeline = function(str, normalize, split, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n//         }\n//\n//         if(str && this.matcher){\n//\n//             str = replace(str, this.matcher);\n//         }\n//\n//         if(this.stemmer && str.length > 1){\n//\n//             str = replace(str, this.stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split || (split === \"\")){\n//\n//                 const words = str.split(/** @type {string|RegExp} */ (split));\n//\n//                 return this.filter ? filter(words, this.filter) : words;\n//             }\n//         }\n//     }\n//\n//     return str;\n// };\n\n// export function pipeline(str, normalize, matcher, stemmer, split, _filter, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, normalize);\n//         }\n//\n//         if(matcher && str){\n//\n//             str = replace(str, matcher);\n//         }\n//\n//         if(stemmer && str.length > 1){\n//\n//             str = replace(str, stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split !== false){\n//\n//                 str = str.split(split);\n//\n//                 if(_filter){\n//\n//                     str = filter(str, _filter);\n//                 }\n//             }\n//         }\n//     }\n//\n//     return str;\n// }\n\n\n/**\n * @param {Array<string>} words\n * @returns {Object<string, string>}\n */\n\nexport function init_filter(words){\n  const filter = create_object();\n\n  for(let i = 0, length = words.length; i < length; i++){\n    filter[words[i]] = 1;\n  }\n\n  return filter;\n}\n\n/**\n * @param {!Object<string, string>} obj\n * @param {boolean} is_stemmer\n * @returns {Array}\n */\n\nexport function init_stemmer_or_matcher(obj, is_stemmer){\n  const keys = get_keys(obj);\n  const length = keys.length;\n  const final = [];\n\n  let removal = '', count = 0;\n\n  for(let i = 0, key, tmp; i < length; i++){\n    key = keys[i];\n    tmp = obj[key];\n\n    if(tmp){\n      final[count++] = regex(is_stemmer ? '(?!\\\\b)' + key + '(\\\\b|_)' : key);\n      final[count++] = tmp;\n    }\n    else{\n      removal += (removal ? '|' : '') + key;\n    }\n  }\n\n  if(removal){\n    final[count++] = regex(is_stemmer ? '(?!\\\\b)(' + removal + ')(\\\\b|_)' : '(' + removal + ')');\n    final[count] = '';\n  }\n\n  return final;\n}\n\n\n/**\n * @param {!string} str\n * @param {Array} regexp\n * @returns {string}\n */\n\nexport function replace(str, regexp){\n  for(let i = 0, len = regexp.length; i < len; i += 2){\n    str = str.replace(regexp[i], regexp[i + 1]);\n\n    if(!str){\n      break;\n    }\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @returns {RegExp}\n */\n\nexport function regex(str){\n  return new RegExp(str, 'g');\n}\n\n/**\n * Regex: replace(/(?:(\\w)(?:\\1)*)/g, \"$1\")\n * @param {!string} string\n * @returns {string}\n */\n\nexport function collapse(string){\n  let final = '', prev = '';\n\n  for(let i = 0, len = string.length, char; i < len; i++){\n    if((char = string[i]) !== prev){\n      final += (prev = char);\n    }\n  }\n\n  return final;\n}\n\n// TODO using fast-swap\nexport function filter(words, map){\n  const length = words.length;\n  const filtered = [];\n\n  for(let i = 0, count = 0; i < length; i++){\n    const word = words[i];\n\n    if(word && !map[word]){\n      filtered[count++] = word;\n    }\n  }\n\n  return filtered;\n}\n\n// const chars = {a:1, e:1, i:1, o:1, u:1, y:1};\n//\n// function collapse_repeating_chars(string){\n//\n//     let collapsed_string = \"\",\n//         char_prev = \"\",\n//         char_next = \"\";\n//\n//     for(let i = 0; i < string.length; i++){\n//\n//         const char = string[i];\n//\n//         if(char !== char_prev){\n//\n//             if(i && (char === \"h\")){\n//\n//                 if((chars[char_prev] && chars[char_next]) || (char_prev === \" \")){\n//\n//                     collapsed_string += char;\n//                 }\n//             }\n//             else{\n//\n//                 collapsed_string += char;\n//             }\n//         }\n//\n//         char_next = (\n//\n//             (i === (string.length - 1)) ?\n//\n//                 \"\"\n//             :\n//                 string[i + 1]\n//         );\n//\n//         char_prev = char;\n//     }\n//\n//     return collapsed_string;\n// }\n","import { pipeline, regex_whitespace } from '../../lang.js';\n\nexport const rtl = false;\nexport const tokenize = '';\nexport default {\n  encode: encode,\n  rtl: rtl,\n  tokenize: tokenize\n};\n\n/**\n * @this IndexInterface\n */\n\nexport function encode(str){\n  return pipeline.call(\n\n    this,\n    /* string: */ ('' + str).toLowerCase(),\n    /* normalize: */ false,\n    /* split: */ regex_whitespace,\n    /* collapse: */ false\n  );\n}\n","//import { promise as Promise } from \"./polyfill.js\";\nimport { is_function } from './common.js';\n\nexport default function(prototype){\n  register(prototype, 'add');\n  register(prototype, 'append');\n  register(prototype, 'search');\n  register(prototype, 'update');\n  register(prototype, 'remove');\n}\n\nfunction register(prototype, key){\n  prototype[key + 'Async'] = function(){\n    /** @type {IndexInterface|DocumentInterface} */\n    const self = this;\n    const args = /*[].slice.call*/(arguments);\n    const arg = args[args.length - 1];\n    let callback;\n\n    if(is_function(arg)){\n      callback = arg;\n      delete args[args.length - 1];\n    }\n\n    const promise = new Promise(function(resolve){\n      setTimeout(function(){\n        self.async = true;\n        const res = self[key].apply(self, args);\n        self.async = false;\n        resolve(res);\n      });\n    });\n\n    if(callback){\n      promise.then(callback);\n      return this;\n    }\n    else{\n      return promise;\n    }\n  };\n}\n","import { create_object } from './common.js';\n\n/**\n * Implementation based on Array.indexOf() provides better performance,\n * but it needs at least one word in the query which is less frequent.\n * Also on large indexes it does not scale well performance-wise.\n * This strategy also lacks of suggestion capabilities (matching & sorting).\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\n// export function intersect(arrays, limit, offset, suggest) {\n//\n//     const length = arrays.length;\n//     let result = [];\n//     let check;\n//\n//     // determine shortest array and collect results\n//     // from the sparse relevance arrays\n//\n//     let smallest_size;\n//     let smallest_arr;\n//     let smallest_index;\n//\n//     for(let x = 0; x < length; x++){\n//\n//         const arr = arrays[x];\n//         const len = arr.length;\n//\n//         let size = 0;\n//\n//         for(let y = 0, tmp; y < len; y++){\n//\n//             tmp = arr[y];\n//\n//             if(tmp){\n//\n//                 size += tmp.length;\n//             }\n//         }\n//\n//         if(!smallest_size || (size < smallest_size)){\n//\n//             smallest_size = size;\n//             smallest_arr = arr;\n//             smallest_index = x;\n//         }\n//     }\n//\n//     smallest_arr = smallest_arr.length === 1 ?\n//\n//         smallest_arr[0]\n//     :\n//         concat(smallest_arr);\n//\n//     if(suggest){\n//\n//         suggest = [smallest_arr];\n//         check = create_object();\n//     }\n//\n//     let size = 0;\n//     let steps = 0;\n//\n//     // process terms in reversed order often results in better performance.\n//     // the outer loop must be the words array, using the\n//     // smallest array here disables the \"fast fail\" optimization.\n//\n//     for(let x = length - 1; x >= 0; x--){\n//\n//         if(x !== smallest_index){\n//\n//             steps++;\n//\n//             const word_arr = arrays[x];\n//             const word_arr_len = word_arr.length;\n//             const new_arr = [];\n//\n//             let count = 0;\n//\n//             for(let z = 0, id; z < smallest_arr.length; z++){\n//\n//                 id = smallest_arr[z];\n//\n//                 let found;\n//\n//                 // process relevance in forward order (direction is\n//                 // important for adding IDs during the last round)\n//\n//                 for(let y = 0; y < word_arr_len; y++){\n//\n//                     const arr = word_arr[y];\n//\n//                     if(arr.length){\n//\n//                         found = arr.indexOf(id) !== -1;\n//\n//                         if(found){\n//\n//                             // check if in last round\n//\n//                             if(steps === length - 1){\n//\n//                                 if(offset){\n//\n//                                     offset--;\n//                                 }\n//                                 else{\n//\n//                                     result[size++] = id;\n//\n//                                     if(size === limit){\n//\n//                                         // fast path \"end reached\"\n//\n//                                         return result;\n//                                     }\n//                                 }\n//\n//                                 if(suggest){\n//\n//                                     check[id] = 1;\n//                                 }\n//                             }\n//\n//                             break;\n//                         }\n//                     }\n//                 }\n//\n//                 if(found){\n//\n//                     new_arr[count++] = id;\n//                 }\n//             }\n//\n//             if(suggest){\n//\n//                 suggest[steps] = new_arr;\n//             }\n//             else if(!count){\n//\n//                 return [];\n//             }\n//\n//             smallest_arr = new_arr;\n//         }\n//     }\n//\n//     if(suggest){\n//\n//         // needs to iterate in reverse direction\n//\n//         for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n//\n//             arr = suggest[x];\n//             len = arr && arr.length;\n//\n//             if(len){\n//\n//                 for(let y = 0, id; y < len; y++){\n//\n//                     id = arr[y];\n//\n//                     if(!check[id]){\n//\n//                         check[id] = 1;\n//\n//                         if(offset){\n//\n//                             offset--;\n//                         }\n//                         else{\n//\n//                             result[size++] = id;\n//\n//                             if(size === limit){\n//\n//                                 // fast path \"end reached\"\n//\n//                                 return result;\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//\n//     return result;\n// }\n\n/**\n * Implementation based on Object[key] provides better suggestions\n * capabilities and has less performance scaling issues on large indexes.\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\nexport function intersect(arrays, limit, offset, suggest) {\n  const length = arrays.length;\n  let result = [];\n  let check;\n  let check_suggest;\n  let size = 0;\n\n  if(suggest){\n    suggest = [];\n  }\n\n  // process terms in reversed order often has advantage for the fast path \"end reached\".\n  // also a reversed order prioritize the order of words from a query.\n\n  for(let x = length - 1; x >= 0; x--){\n    const word_arr = arrays[x];\n    const word_arr_len = word_arr.length;\n    const check_new = create_object();\n\n    let found = !check;\n\n    // process relevance in forward order (direction is\n    // important for adding IDs during the last round)\n\n    for(let y = 0; y < word_arr_len; y++){\n      const arr = word_arr[y];\n      const arr_len = arr.length;\n\n      if(arr_len){\n        // loop through IDs\n\n        for(let z = 0, check_idx, id; z < arr_len; z++){\n          id = arr[z];\n\n          if(check){\n            if(check[id]){\n              // check if in last round\n\n              if(!x){\n                if(offset){\n                  offset--;\n                }\n                else{\n                  result[size++] = id;\n\n                  if(size === limit){\n                    // fast path \"end reached\"\n\n                    return result;\n                  }\n                }\n              }\n\n              if(x || suggest){\n                check_new[id] = 1;\n              }\n\n              found = true;\n            }\n\n            if(suggest){\n              check_idx = check_suggest[id];\n              check_suggest[id] = check_idx ? ++check_idx : check_idx = 1;\n\n              // do not adding IDs which are already included in the result (saves one loop)\n              // the first intersection match has the check index 2, so shift by -2\n\n              if(check_idx < length){\n                const tmp = suggest[check_idx - 2] || (suggest[check_idx - 2] = []);\n                tmp[tmp.length] = id;\n              }\n            }\n          }\n          else{\n            // pre-fill in first round\n\n            check_new[id] = 1;\n          }\n        }\n      }\n    }\n\n    if(suggest){\n      // re-use the first pre-filled check for suggestions\n\n      check || (check_suggest = check_new);\n    }\n    else if(!found){\n      return [];\n    }\n\n    check = check_new;\n  }\n\n  if(suggest){\n    // needs to iterate in reverse direction\n\n    for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n      arr = suggest[x];\n      len = arr.length;\n\n      for(let y = 0, id; y < len; y++){\n        id = arr[y];\n\n        if(!check[id]){\n          if(offset){\n            offset--;\n          }\n          else{\n            result[size++] = id;\n\n            if(size === limit){\n              // fast path \"end reached\"\n\n              return result;\n            }\n          }\n\n          check[id] = 1;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * @param mandatory\n * @param arrays\n * @returns {Array}\n */\n\nexport function intersect_union(mandatory, arrays) {\n  const check = create_object();\n  const union = create_object();\n  const result = [];\n\n  for(let x = 0; x < mandatory.length; x++){\n    check[mandatory[x]] = 1;\n  }\n\n  for(let x = 0, arr; x <  arrays.length; x++){\n    arr = arrays[x];\n\n    for(let y = 0, id; y < arr.length; y++){\n      id = arr[y];\n\n      if(check[id]){\n        if(!union[id]){\n          union[id] = 1;\n          result[result.length] = id;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { create_object, is_object } from './common.js';\n\n/**\n * @param {boolean|number=} limit\n * @constructor\n */\n\nfunction CacheClass(limit){\n  /** @private */\n  this.limit = (limit !== true) && limit;\n\n  /** @private */\n  this.cache = create_object();\n\n  /** @private */\n  this.queue = [];\n\n  //this.clear();\n}\n\nexport default CacheClass;\n\n/**\n * @param {string|Object} query\n * @param {number|Object=} limit\n * @param {Object=} options\n * @this {IndexInterface}\n * @returns {Array<number|string>}\n */\n\nexport function searchCache(query, limit, options){\n  if(is_object(query)){\n    query = query.query;\n  }\n\n  let cache = this.cache.get(query);\n\n  if(!cache){\n    cache = this.search(query, limit, options);\n    this.cache.set(query, cache);\n  }\n\n  return cache;\n}\n\n// CacheClass.prototype.clear = function(){\n//\n//     /** @private */\n//     this.cache = create_object();\n//\n//     /** @private */\n//     this.queue = [];\n// };\n\nCacheClass.prototype.set = function(key, value){\n  if(!this.cache[key]){\n    // it is just a shame that native function array.shift() performs so bad\n\n    // const length = this.queue.length;\n    //\n    // this.queue[length] = key;\n    //\n    // if(length === this.limit){\n    //\n    //     delete this.cache[this.queue.shift()];\n    // }\n\n    // the same bad performance\n\n    // this.queue.unshift(key);\n    //\n    // if(this.queue.length === this.limit){\n    //\n    //     this.queue.pop();\n    // }\n\n    // fast implementation variant\n\n    // let length = this.queue.length;\n    //\n    // if(length === this.limit){\n    //\n    //     length--;\n    //\n    //     delete this.cache[this.queue[0]];\n    //\n    //     for(let x = 0; x < length; x++){\n    //\n    //         this.queue[x] = this.queue[x + 1];\n    //     }\n    // }\n    //\n    // this.queue[length] = key;\n\n    // current fastest implementation variant\n    // theoretically that should not perform better compared to the example above\n\n    let length = this.queue.length;\n\n    if(length === this.limit){\n      delete this.cache[this.queue[length - 1]];\n    }\n    else{\n      length++;\n    }\n\n    for(let x = length - 1; x > 0; x--){\n      this.queue[x] = this.queue[x - 1];\n    }\n\n    this.queue[0] = key;\n  }\n\n  this.cache[key] = value;\n};\n\nCacheClass.prototype.get = function(key){\n  const cache = this.cache[key];\n\n  if(this.limit && cache){\n    // probably the indexOf() method performs faster when matched content is on front (left-to-right)\n    // using lastIndexOf() does not help, it performs almost slower\n\n    const pos = this.queue.indexOf(key);\n\n    // if(pos < this.queue.length - 1){\n    //\n    //     const tmp = this.queue[pos];\n    //     this.queue[pos] = this.queue[pos + 1];\n    //     this.queue[pos + 1] = tmp;\n    // }\n\n    if(pos){\n      const tmp = this.queue[pos - 1];\n      this.queue[pos - 1] = this.queue[pos];\n      this.queue[pos] = tmp;\n    }\n  }\n\n  return cache;\n};\n\nCacheClass.prototype.del = function(id){\n  for(let i = 0, item, key; i < this.queue.length; i++){\n    key = this.queue[i];\n    item = this.cache[key];\n\n    if(item.indexOf(id) !== -1){\n      this.queue.splice(i--, 1);\n      delete this.cache[key];\n    }\n  }\n};\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { encode as default_encoder } from './lang/latin/default.js';\nimport { create_object, create_object_array, concat, sort_by_length_down, is_array, is_object, parse_option } from './common.js';\nimport { init_stemmer_or_matcher, init_filter } from './lang.js';\nimport apply_async from './async.js';\nimport { intersect } from './intersect.js';\nimport Cache, { searchCache } from './cache.js';\n\n/**\n * @constructor\n * @param {Object=} options\n * @return {Index}\n */\n\nexport class Index {\n  constructor(options = {}) {\n    this.encode = default_encoder;\n    this.register = create_object();\n    this.resolution = options.resolution || 9;\n    this.tokenize = options.tokenize || 'strict';\n    this.depth = options?.context?.depth;\n    this.bidirectional = parse_option(options?.context?.bidirectional, true);\n    this.optimize = parse_option(options.optimize, true);\n    this.minlength = options.minlength || 1;\n    this.boost = options.boost;\n\n    // when not using the memory strategy the score array should not pre-allocated to its full length\n    this.map = this.optimize ? create_object_array(options?.context?.resolution || 9) : create_object();\n    this.resolution_ctx = options?.context?.resolution || 1;\n    this.ctx = this.optimize ? create_object_array(options?.context?.resolution || 1) : create_object();\n    this.rtl = options.rtl;\n    this.matcher = options.matcher && init_stemmer_or_matcher(options.matcher, false);\n    this.stemmer = options.stemmer && init_stemmer_or_matcher(options.stemmer, true);\n    this.filter = options.filter && init_filter(options.filter);\n    this.cache = options.cache && new Cache(options.cache);\n  }\n  //Index.prototype.pipeline = pipeline;\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   */\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   * @param {boolean=} _append\n   * @param {boolean=} _skip_update\n   */\n  add(id, content, _append, _skip_update) {\n    if (content && (id || (id === 0))) {\n      if (!_skip_update && !_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      content = this.encode(content);\n      const length = content.length;\n\n      if (length) {\n        // check context dupes to skip all contextual redundancy along a document\n        const dupes_ctx = create_object();\n        const dupes = create_object();\n        const depth = this.depth;\n        const resolution = this.resolution;\n\n        for (let i = 0; i < length; i++) {\n          let term = content[this.rtl ? length - 1 - i : i];\n          let term_length = term.length;\n\n          // skip dupes will break the context chain\n          if (term && (term_length >= this.minlength) && (depth || !dupes[term])) {\n            let score = get_score(resolution, length, i);\n            let token = '';\n\n            switch (this.tokenize) {\n            case 'full':\n\n              if (term_length > 3) {\n                for (let x = 0; x < term_length; x++) {\n                  for (let y = term_length; y > x; y--) {\n                    if ((y - x) >= this.minlength) {\n                      const partial_score = get_score(resolution, length, i, term_length, x);\n                      token = term.substring(x, y);\n                      this.push_index(dupes, token, partial_score, id, _append);\n                    }\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when term length < 4\n            case 'reverse':\n\n              // skip last round (this token exist already in \"forward\")\n              if (term_length > 2) {\n                for (let x = term_length - 1; x > 0; x--) {\n                  token = term[x] + token;\n\n                  if (token.length >= this.minlength) {\n                    const partial_score = get_score(resolution, length, i, term_length, x);\n                    this.push_index(dupes, token, partial_score, id, _append);\n                  }\n                }\n\n                token = '';\n              }\n\n              // fallthrough to next case to apply forward also\n            case 'forward':\n\n              if (term_length > 1) {\n                for (let x = 0; x < term_length; x++) {\n                  token += term[x];\n\n                  if (token.length >= this.minlength) {\n                    this.push_index(dupes, token, score, id, _append);\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when token has a length of 1\n            default:\n              // case \"strict\":\n              if (this.boost) {\n                score = Math.min((score / this.boost(content, term, i)) | 0, resolution - 1);\n              }\n\n              this.push_index(dupes, term, score, id, _append);\n\n              // context is just supported by tokenizer \"strict\"\n              if (depth) {\n                if ((length > 1) && (i < (length - 1))) {\n                  // check inner dupes to skip repeating words in the current context\n                  const dupes_inner = create_object();\n                  const resolution = this.resolution_ctx;\n                  const keyword = term;\n                  const size = Math.min(depth + 1, length - i);\n\n                  dupes_inner[keyword] = 1;\n\n                  for (let x = 1; x < size; x++) {\n                    term = content[this.rtl ? length - 1 - i - x : i + x];\n\n                    if (term && (term.length >= this.minlength) && !dupes_inner[term]) {\n                      dupes_inner[term] = 1;\n\n                      const context_score = get_score(resolution + ((length / 2) > resolution ? 0 : 1), length, i, size - 1, x - 1);\n                      const swap = this.bidirectional && (term > keyword);\n                      this.push_index(dupes_ctx, swap ? keyword : term, context_score, id, _append, swap ? term : keyword);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * @param dupes\n   * @param value\n   * @param score\n   * @param id\n   * @param {boolean=} append\n   * @param {string=} keyword\n   */\n  push_index(dupes, value, score, id, append, keyword) {\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!dupes[value] || (keyword && !dupes[value][keyword])) {\n      if (this.optimize) {\n        arr = arr[score];\n      }\n\n      if (keyword) {\n        dupes = dupes[value] || (dupes[value] = create_object());\n        dupes[keyword] = 1;\n\n        arr = arr[keyword] || (arr[keyword] = create_object());\n      }\n      else {\n        dupes[value] = 1;\n      }\n\n      arr = arr[value] || (arr[value] = []);\n\n      if (!this.optimize) {\n        arr = arr[score] || (arr[score] = []);\n      }\n\n      if (!append || (arr.indexOf(id) === -1)) {\n        arr[arr.length] = id;\n        this.register[id] ||= [];\n        this.register[id].push(arr);\n      }\n    }\n  }\n  /**\n   * @param {string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @returns {Array<number|string>}\n   */\n  search(query, limit, options) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options.query;\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n      }\n    }\n\n    let result = [];\n    let length;\n    let context, suggest, offset = 0;\n\n    if (options) {\n      limit = options.limit;\n      offset = options.offset || 0;\n      context = options.context;\n      suggest = options.suggest;\n    }\n\n    if (query) {\n      query = /** @type {Array} */ (this.encode(query));\n      length = query.length;\n\n      // TODO: solve this in one single loop below\n      if (length > 1) {\n        const dupes = create_object();\n        const query_new = [];\n\n        for (let i = 0, count = 0, term; i < length; i++) {\n          term = query[i];\n\n          if (term && (term.length >= this.minlength) && !dupes[term]) {\n            // this fast path just could applied when not in memory-optimized mode\n            if (!this.optimize && !suggest && !this.map[term]) {\n              // fast path \"not found\"\n              return result;\n            }\n            else {\n              query_new[count++] = term;\n              dupes[term] = 1;\n            }\n          }\n        }\n\n        query = query_new;\n        length = query.length;\n      }\n    }\n\n    if (!length) {\n      return result;\n    }\n\n    limit || (limit = 100);\n\n    let depth = this.depth && (length > 1) && (context !== false);\n    let index = 0, keyword;\n\n    if (depth) {\n      keyword = query[0];\n      index = 1;\n    }\n    else {\n      if (length > 1) {\n        query.sort(sort_by_length_down);\n      }\n    }\n\n    for (let arr, term; index < length; index++) {\n      term = query[index];\n\n      // console.log(keyword);\n      // console.log(term);\n      // console.log(\"\");\n      if (depth) {\n        arr = this.add_result(result, suggest, limit, offset, length === 2, term, keyword);\n\n        // console.log(arr);\n        // console.log(result);\n        // when suggestion enabled just forward keyword if term was found\n        // as long as the result is empty forward the pointer also\n        if (!suggest || (arr !== false) || !result.length) {\n          keyword = term;\n        }\n      }\n      else {\n        arr = this.add_result(result, suggest, limit, offset, length === 1, term);\n      }\n\n      if (arr) {\n        return /** @type {Array<number|string>} */ (arr);\n      }\n\n      // apply suggestions on last loop or fallback\n      if (suggest && (index === length - 1)) {\n        let length = result.length;\n\n        if (!length) {\n          if (depth) {\n            // fallback to non-contextual search when no result was found\n            depth = 0;\n            index = -1;\n\n            continue;\n          }\n\n          return result;\n        }\n        else if (length === 1) {\n          // fast path optimization\n          return single_result(result[0], limit, offset);\n        }\n      }\n    }\n\n    return intersect(result, limit, offset, suggest);\n  }\n  /**\n   * Returns an array when the result is done (to stop the process immediately),\n   * returns false when suggestions is enabled and no result was found,\n   * or returns nothing when a set was pushed successfully to the results\n   *\n   * @private\n   * @param {Array} result\n   * @param {Array} suggest\n   * @param {number} limit\n   * @param {number} offset\n   * @param {boolean} single_term\n   * @param {string} term\n   * @param {string=} keyword\n   * @return {Array<Array<string|number>>|boolean|undefined}\n   */\n  add_result(result, suggest, limit, offset, single_term, term, keyword) {\n    let word_arr = [];\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!this.optimize) {\n      arr = get_array(arr, term, keyword, this.bidirectional);\n    }\n\n    if (arr) {\n      let count = 0;\n      const arr_len = Math.min(arr.length, keyword ? this.resolution_ctx : this.resolution);\n\n      // relevance:\n      for (let x = 0, size = 0, tmp, len; x < arr_len; x++) {\n        tmp = arr[x];\n\n        if (tmp) {\n          if (this.optimize) {\n            tmp = get_array(tmp, term, keyword, this.bidirectional);\n          }\n\n          if (offset) {\n            if (tmp && single_term) {\n              len = tmp.length;\n\n              if (len <= offset) {\n                offset -= len;\n                tmp = null;\n              }\n              else {\n                tmp = tmp.slice(offset);\n                offset = 0;\n              }\n            }\n          }\n\n          if (tmp) {\n            // keep score (sparse array):\n            //word_arr[x] = tmp;\n            // simplified score order:\n            word_arr[count++] = tmp;\n\n            if (single_term) {\n              size += tmp.length;\n\n              if (size >= limit) {\n                // fast path optimization\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (count) {\n        if (single_term) {\n          // fast path optimization\n          // offset was already applied at this point\n          return single_result(word_arr, limit, 0);\n        }\n\n        result[result.length] = word_arr;\n        return;\n      }\n    }\n\n    // return an empty array will stop the loop,\n    // to prevent stop when using suggestions return a false value\n    return !suggest && word_arr;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  /**\n   * @param {boolean=} _skip_deletion\n   */\n  remove(id, _skip_deletion) {\n    const refs = this.register[id];\n\n    if (refs) {\n      remove_index(this.map, id, this.resolution, this.optimize);\n\n      if (this.depth) {\n        remove_index(this.ctx, id, this.resolution_ctx, this.optimize);\n      }\n\n      _skip_deletion || delete this.register[id];\n\n      if (this.cache) {\n        this.cache.del(id);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Convert `this` into an exportable object\n   */\n  serialize() {\n    return {\n      reg: this.register,\n      opt: this.optimize,\n      map: this.map,\n      ctx: this.ctx\n    };\n  }\n\n  /**\n   * Given a string load an Index object from it\n   * @param {string} str the serialized Index object\n   */\n  static deserialize(obj, params) {\n    // TODO add extra parameter for index initialization?\n    const result = new Index(params);\n    result.optimize = obj.opt;\n    result.register = obj.reg;\n    result.map      = obj.map;\n    result.ctx      = obj.ctx;\n    return result;\n  }\n}\n\n\n\n/**\n * @param {number} resolution\n * @param {number} length\n * @param {number} i\n * @param {number=} term_length\n * @param {number=} x\n * @returns {number}\n */\n\nfunction get_score(resolution, length, i, term_length, x){\n  // console.log(\"resolution\", resolution);\n  // console.log(\"length\", length);\n  // console.log(\"term_length\", term_length);\n  // console.log(\"i\", i);\n  // console.log(\"x\", x);\n  // console.log((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1);\n\n  // the first resolution slot is reserved for the best match,\n  // when a query matches the first word(s).\n\n  // also to stretch score to the whole range of resolution, the\n  // calculation is shift by one and cut the floating point.\n  // this needs the resolution \"1\" to be handled additionally.\n\n  // do not stretch the resolution more than the term length will\n  // improve performance and memory, also it improves scoring in\n  // most cases between a short document and a long document\n\n  return i && (resolution > 1) ? (\n\n    (length + (term_length || 0)) <= resolution ?\n\n      i + (x || 0)\n      :\n      ((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1) | 0\n  ):\n    0;\n}\n\n\n\n\nfunction single_result(result, limit, offset){\n  if(result.length === 1){\n    result = result[0];\n  }\n  else{\n    result = concat(result);\n  }\n\n  return offset || (result.length > limit) ?\n\n    result.slice(offset, offset + limit)\n    :\n    result;\n}\n\nfunction get_array(arr, term, keyword, bidirectional){\n  if(keyword){\n    // the frequency of the starting letter is slightly less\n    // on the last half of the alphabet (m-z) in almost every latin language,\n    // so we sort downwards (https://en.wikipedia.org/wiki/Letter_frequency)\n\n    const swap = bidirectional && (term > keyword);\n\n    arr = arr[swap ? term : keyword];\n    arr = arr && arr[swap ? keyword : term];\n  }\n  else{\n    arr = arr[term];\n  }\n\n  return arr;\n}\n\n\n\n\n/**\n * @param map\n * @param id\n * @param res\n * @param optimize\n * @param {number=} resolution\n * @return {number}\n */\n\nfunction remove_index(map, id, res, optimize, resolution){\n  let count = 0;\n\n  if(is_array(map)){\n    // the first array is the score array in both strategies\n\n    if(!resolution){\n      resolution = Math.min(map.length, res);\n\n      for(let x = 0, arr; x < resolution; x++){\n        arr = map[x];\n\n        if(arr){\n          count = remove_index(arr, id, res, optimize, resolution);\n\n          if(!optimize && !count){\n            // when not memory optimized the score index should removed\n\n            delete map[x];\n          }\n        }\n      }\n    }\n    else{\n      const pos = map.indexOf(id);\n\n      if(pos !== -1){\n        // fast path, when length is 1 or lower then the whole field gets deleted\n\n        if(map.length > 1){\n          map.splice(pos, 1);\n          count++;\n        }\n      }\n      else{\n        count++;\n      }\n    }\n  }\n  else{\n    for(let key in map){\n      count = remove_index(map[key], id, res, optimize, resolution);\n\n      if(!count){\n        delete map[key];\n      }\n    }\n  }\n\n  return count;\n}\n\n// TODO bring all these functions into this file\nIndex.prototype.searchCache = searchCache;\napply_async(Index.prototype);\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { Index } from './index.js';\nimport Cache, { searchCache } from './cache.js';\nimport { create_object, is_array, is_string, is_object } from './common.js';\nimport apply_async from './async.js';\nimport { intersect, intersect_union } from './intersect.js';\n\n/**\n * @constructor\n * @implements DocumentInterface\n * @param {Object=} options\n * @return {Document}\n */\n\nexport class Document {\n  constructor(options) {\n    const document = options.document || options.doc || options;\n    let opt;\n\n    this.tree = [];\n    this.field = [];\n    this.marker = [];\n    this.register = create_object();\n    this.key = ((opt = document.key || document.id) && parse_tree(opt, this.marker)) || 'id';\n\n    this.storetree = (opt = document.store) && (opt !== true) && [];\n    this.store = opt && create_object();\n\n    this.tag = ((opt = document.tag) && parse_tree(opt, this.marker));\n    this.tagindex = opt && create_object();\n\n    this.cache = (opt = options.cache) && new Cache(opt);\n\n    // do not apply cache again for the indexes\n    options.cache = false;\n\n    this.worker = options.worker;\n\n    // this switch is used by recall of promise callbacks\n    this.async = false;\n\n    this.index = this.parse_descriptor(options, document);\n  }\n\n  /**\n   *\n   * @param id\n   * @param content\n   * @param {boolean=} _append\n   * @returns {Document|Promise}\n   */\n  add(id, content, _append) {\n    if (is_object(id)) {\n      content = id;\n      id = parse_simple(content, this.key);\n    }\n\n    if (content && (id || (id === 0))) {\n      if (!_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      for (let i = 0, tree, field; i < this.field.length; i++) {\n        field = this.field[i];\n        tree = this.tree[i];\n\n        if (is_string(tree)) {\n          tree = [tree];\n        }\n\n        add_index(content, tree, this.marker, 0, this.index[field], id, tree[0], _append);\n      }\n\n      if (this.tag) {\n        let tag = parse_simple(content, this.tag);\n        let dupes = create_object();\n\n        if (is_string(tag)) {\n          tag = [tag];\n        }\n\n        for (let i = 0, key, arr; i < tag.length; i++) {\n          key = tag[i];\n\n          if (!dupes[key]) {\n            dupes[key] = 1;\n            arr = this.tagindex[key] || (this.tagindex[key] = []);\n\n            if (!_append || (arr.indexOf(id) === -1)) {\n              arr[arr.length] = id;\n            }\n          }\n        }\n      }\n\n      // TODO: how to handle store when appending contents?\n      if (this.store && (!_append || !this.store[id])) {\n        let store;\n\n        if (this.storetree) {\n          store = create_object();\n\n          for (let i = 0, tree; i < this.storetree.length; i++) {\n            tree = this.storetree[i];\n\n            if (is_string(tree)) {\n              store[tree] = content[tree];\n            }\n            else {\n              store_value(content, store, tree, 0, tree[0]);\n            }\n          }\n        }\n\n        this.store[id] = store || content;\n      }\n    }\n\n    return this;\n  }\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  remove(id) {\n    if (is_object(id)) {\n      id = parse_simple(id, this.key);\n    }\n\n    if (this.register[id]) {\n      for (let i = 0; i < this.field.length; i++) {\n        // workers does not share the register\n        this.index[this.field[i]].remove(id, !this.worker);\n      }\n\n      if (this.tag) {\n        for (let key in this.tagindex) {\n          const tag = this.tagindex[key];\n          const pos = tag.indexOf(id);\n\n          if (pos !== -1) {\n            if (tag.length > 1) {\n              tag.splice(pos, 1);\n            }\n            else {\n              delete this.tagindex[key];\n            }\n          }\n        }\n      }\n\n      if (this.store) {\n        delete this.store[id];\n      }\n\n      delete this.register[id];\n    }\n\n    return this;\n  }\n  /**\n   * @param {!string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @param {Array<Array>=} _resolve For internal use only.\n   * @returns {Promise|Array}\n   */\n  search(query, limit, options, _resolve) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options.query;\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n        limit = 0;\n      }\n    }\n\n    let result = [], result_field = [];\n    let pluck, enrich;\n    let field, tag, bool, offset, count = 0;\n\n    if (options) {\n      if (is_array(options)) {\n        field = options;\n        options = null;\n      }\n      else {\n        pluck = options.pluck;\n        field = pluck || options.index || options.field /*|| (is_string(options) && [options])*/;\n        tag = options.tag;\n        enrich = this.store && options.enrich;\n        bool = options.bool === 'and';\n        limit = options.limit || 100;\n        offset = options.offset || 0;\n\n        if (tag) {\n          if (is_string(tag)) {\n            tag = [tag];\n          }\n\n          // when tags is used and no query was set,\n          // then just return the tag indexes\n          if (!query) {\n            for (let i = 0, res; i < tag.length; i++) {\n              res = get_tag.call(this, tag[i], limit, offset, enrich);\n\n              if (res) {\n                result[result.length] = res;\n                count++;\n              }\n            }\n\n            return count ? result : [];\n          }\n        }\n\n        if (is_string(field)) {\n          field = [field];\n        }\n      }\n    }\n\n    field || (field = this.field);\n    bool = bool && ((field.length > 1) || (tag && (tag.length > 1)));\n\n    const promises = !_resolve && (this.worker || this.async) && [];\n\n    // TODO solve this in one loop below\n    for (let i = 0, res, key, len; i < field.length; i++) {\n      let opt;\n\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key.field;\n      }\n\n      if (promises) {\n        promises[i] = this.index[key].searchAsync(query, limit, opt || options);\n\n        // just collect and continue\n        continue;\n      }\n      else if (_resolve) {\n        res = _resolve[i];\n      }\n      else {\n        // inherit options also when search? it is just for laziness, Object.assign() has a cost\n        res = this.index[key].search(query, limit, opt || options);\n      }\n\n      len = res && res.length;\n\n      if (tag && len) {\n        const arr = [];\n        let count = 0;\n\n        if (bool) {\n          // prepare for intersection\n          arr[0] = [res];\n        }\n\n        for (let y = 0, key, res; y < tag.length; y++) {\n          key = tag[y];\n          res = this.tagindex[key];\n          len = res && res.length;\n\n          if (len) {\n            count++;\n            arr[arr.length] = bool ? [res] : res;\n          }\n        }\n\n        if (count) {\n          if (bool) {\n            res = intersect(arr, limit || 100, offset || 0);\n          }\n          else {\n            res = intersect_union(res, arr);\n          }\n\n          len = res.length;\n        }\n      }\n\n      if (len) {\n        result_field[count] = key;\n        result[count++] = res;\n      }\n      else if (bool) {\n        return [];\n      }\n    }\n\n    if (promises) {\n      const self = this;\n\n      // anyone knows a better workaround of optionally having async promises?\n      // the promise.all() needs to be wrapped into additional promise,\n      // otherwise the recursive callback wouldn't run before return\n      return new Promise(function (resolve) {\n        Promise.all(promises).then(function (result) {\n          resolve(self.search(query, limit, options, result));\n        });\n      });\n    }\n\n    if (!count) {\n      // fast path \"not found\"\n      return [];\n    }\n\n    if (pluck && (!enrich || !this.store)) {\n      // fast path optimization\n      return result[0];\n    }\n\n    for (let i = 0, res; i < result_field.length; i++) {\n      res = result[i];\n\n      if (res.length) {\n        if (enrich) {\n          res = apply_enrich.call(this, res);\n        }\n      }\n\n      if (pluck) {\n        return res;\n      }\n\n      result[i] = {\n        'field': result_field[i],\n        'result': res\n      };\n    }\n\n    return result;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  get(id) {\n    return this.store[id];\n  }\n  set(id, data) {\n    this.store[id] = data;\n    return this;\n  }\n\n  /**\n   * Serialize `this` into an exportable object\n   */\n  serialize() {\n    const result = {\n      tag:   this.tagIndex,\n      reg:   this.register,\n      store: this.store,\n      field: this.field,\n      index: {}\n    };\n    Object.entries(this.index).forEach(([key, index]) => {\n      result.index[key] = index.serialize();\n    });\n    return result;\n  }\n\n  /**\n   * Create a `Document` from a serialized object\n   */\n  static deserialize(obj, params) {\n    // TODO add properties here?\n    const result = new Document(params);\n    result.tagIndex = obj.tag;\n    result.register = obj.reg;\n    result.store    = obj.store;\n    result.field    = obj.field;\n    Object.entries(obj.index).forEach(([key, exportedIndex]) => {\n      result.index[key] = Index.deserialize(exportedIndex);\n      result.index[key].register = obj.reg;\n    });\n    return result;\n  }\n\n  // Helper methods\n\n  parse_descriptor(options, document) {\n    const index = create_object();\n    let field = document.index || document.field || document;\n\n    if (is_string(field)) {\n      field = [field];\n    }\n\n    for (let i = 0, key, opt; i < field.length; i++) {\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key.field;\n      }\n\n      opt = is_object(opt) ? Object.assign({}, options, opt) : options;\n\n      if (!this.worker) {\n        index[key] = new Index(opt);\n        index[key].register = this.register;\n      }\n\n      this.tree[i] = parse_tree(key, this.marker);\n      this.field[i] = key;\n    }\n\n    if (this.storetree) {\n      let store = document.store;\n\n      if (is_string(store)) {\n        store = [store];\n      }\n\n      for (let i = 0; i < store.length; i++) {\n        this.storetree[i] = parse_tree(store[i], this.marker);\n      }\n    }\n\n    return index;\n  }\n}\n\nfunction parse_tree(key, marker){\n  const tree = key.split(':');\n  let count = 0;\n\n  for(let i = 0; i < tree.length; i++){\n    key = tree[i];\n\n    if(key.indexOf('[]') >= 0){\n      key = key.substring(0, key.length - 2);\n\n      if(key){\n        marker[count] = true;\n      }\n    }\n\n    if(key){\n      tree[count++] = key;\n    }\n  }\n\n  if(count < tree.length){\n    tree.length = count;\n  }\n\n  return count > 1 ? tree : tree[0];\n}\n\nfunction parse_simple(obj, tree){\n  if(is_string(tree)){\n    obj = obj[tree];\n  }\n  else{\n    for(let i = 0; obj && (i < tree.length); i++){\n      obj = obj[tree[i]];\n    }\n  }\n\n  return obj;\n}\n\nfunction store_value(obj, store, tree, pos, key){\n  obj = obj[key];\n\n  // reached target field\n\n  if(pos === (tree.length - 1)){\n    // store target value\n\n    store[key] = obj;\n  }\n  else if(obj){\n    if(is_array(obj)){\n      store = store[key] = new Array(obj.length);\n\n      for(let i = 0; i < obj.length; i++){\n        // do not increase pos (an array is not a field)\n        store_value(obj, store, tree, pos, i);\n      }\n    }\n    else{\n      store = store[key] || (store[key] = create_object());\n      key = tree[++pos];\n\n      store_value(obj, store, tree, pos, key);\n    }\n  }\n}\n\nfunction add_index(obj, tree, marker, pos, index, id, key, _append){\n  obj = obj[key];\n\n  if(obj){\n    // reached target field\n\n    if(pos === (tree.length - 1)){\n      // handle target value\n\n      if(is_array(obj)){\n        // append array contents so each entry gets a new scoring context\n\n        if(marker[pos]){\n          for(let i = 0; i < obj.length; i++){\n            index.add(id, obj[i], /* append: */ true, /* skip update: */ true);\n          }\n\n          return;\n        }\n\n        // or join array contents and use one scoring context\n\n        obj = obj.join(' ');\n      }\n\n      index.add(id, obj, _append, /* skip_update: */ true);\n    }\n    else{\n      if(is_array(obj)){\n        for(let i = 0; i < obj.length; i++){\n          // do not increase index, an array is not a field\n\n          add_index(obj, tree, marker, pos, index, id, i, _append);\n        }\n      }\n      else{\n        key = tree[++pos];\n\n        add_index(obj, tree, marker, pos, index, id, key, _append);\n      }\n    }\n  }\n}\n\n\n\n\n\n\n/**\n * @this Document\n */\n\nfunction get_tag(key, limit, offset, enrich){\n  let res = this.tagindex[key];\n  let len = res && (res.length - offset);\n\n  if(len && (len > 0)){\n    if((len > limit) || offset){\n      res = res.slice(offset, offset + limit);\n    }\n\n    if(enrich){\n      res = apply_enrich.call(this, res);\n    }\n\n    return {\n\n      'tag': key,\n      'result': res\n    };\n  }\n}\n\n/**\n * @this Document\n */\n\nfunction apply_enrich(res){\n  const arr = new Array(res.length);\n\n  for(let x = 0, id; x < res.length; x++){\n    id = res[x];\n\n    arr[x] = {\n\n      'id': id,\n      'doc': this.store[id]\n    };\n  }\n\n  return arr;\n}\n\n// TODO move all of this into this file\nDocument.prototype.searchCache = searchCache;\napply_async(Document.prototype);\n","import { Index } from './index';\nimport { Document } from './document';\n\n// TODO Worker, registerCharset, registerLanguage\nexport default { Index, Document };\n"],"names":["parse_option","value","default_value","create_object_array","count","array","Array","i","create_object","Object","create","sort_by_length_down","a","b","length","is_array","val","constructor","is_string","is_object","is_function","pipeline","str","normalize","split","_collapse","replace","this","matcher","stemmer","string","final","prev","char","len","collapse","words","filter","map","filtered","word","regex_whitespace","init_stemmer_or_matcher","obj","is_stemmer","keys","get_keys","removal","key","tmp","regex","regexp","RegExp","encode","call","toLowerCase","prototype","register","self","args","arg","callback","promise","Promise","resolve","setTimeout","async","res","apply","then","intersect","arrays","limit","offset","suggest","check","check_suggest","result","size","x","word_arr","word_arr_len","check_new","found","y","arr","arr_len","check_idx","id","z","intersect_union","mandatory","union","CacheClass","cache","queue","searchCache","query","options","get","search","set","pos","indexOf","del","item","splice","Index","default_encoder","resolution","tokenize","depth","context","bidirectional","optimize","minlength","boost","resolution_ctx","ctx","rtl","init_filter","Cache","append","content","add","_append","_skip_update","update","dupes_ctx","dupes","term","term_length","score","get_score","token","partial_score","substring","push_index","Math","min","dupes_inner","keyword","context_score","swap","push","query_new","index","sort","add_result","single_result","single_term","get_array","slice","contain","remove","_skip_deletion","remove_index","serialize","reg","opt","deserialize","params","concat","apply_async","Document","document","doc","tree","field","marker","parse_tree","storetree","store","tag","tagindex","worker","parse_descriptor","parse_simple","add_index","store_value","_resolve","pluck","enrich","bool","result_field","get_tag","promises","searchAsync","all","apply_enrich","data","tagIndex","entries","forEach","exportedIndex","assign","join"],"mappings":"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"}